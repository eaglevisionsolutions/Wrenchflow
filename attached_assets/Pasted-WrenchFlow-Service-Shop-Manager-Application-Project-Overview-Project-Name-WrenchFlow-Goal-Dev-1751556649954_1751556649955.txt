WrenchFlow: Service Shop Manager Application 
Project Overview
Project Name: WrenchFlow
Goal: Develop a full-stack web application for small engine repair shops to efficiently manage customers, equipment, parts inventory, work orders, and employee information. This application will operate on a Software-as-a-Service (SaaS) model, allowing multiple independent shops to subscribe and use the system. It must include robust offline capabilities and automatic synchronization for each individual shop's data.
Target Audience: Owners, managers, and technicians of small engine repair shops (e.g., lawnmower repair, snowblower repair, chainsaw service, ATV service).
Key Selling Points/Unique Features:
Intuitive interface for shop management.
Comprehensive customer and equipment tracking.
Real-time parts inventory with bin locations, including management of bulk oils and fluids, and a robust parts ordering and receiving system with vendor management.
Detailed work order creation with service history.
Service Appointment Scheduling: Customers can book appointments, and shop staff can manage them.
Sales Tracking & Reporting: Track and report on both parts and service sales, including over-the-counter parts sales, with role-based access.
User-Customizable Themes: Shop administrators and employees can switch between pre-defined application themes for their personal view.
Multi-Tenant Architecture: Each subscribing shop will have its own isolated data. Shops can only access their own information.
Super Admin Access: A platform-level administrator (me) and my employees will have full access to view and manage data across all shops.
Crucial Offline-First functionality: The app must be fully functional offline for each shop's data, storing all data locally and syncing automatically when an internet connection is detected.
Technical Stack & Architecture
Frontend:
Core Language: JavaScript (Vanilla JS or jQuery, or a combination of both where it makes sense, with clear modular structure)
UI: Standard HTML5 and CSS3 (with a modern, clean aesthetic using Bootstrap and custom CSS for utility-first styling, along with CSS Transitions for smooth interactions and theme management).
Interaction: JSON-based API communication via AJAX (Fetch API).
Local Storage for Offline: IndexedDB for persistent, structured local data storage. This is critical for offline operation.
Offline Sync Logic: JavaScript logic to detect online/offline status, queue operations for sync, and manage data consistency between IndexedDB and the backend, ensuring all data operations are scoped to the current logged-in shop's ID.
Backend:
Language/Framework: PHP (Pure Object-Oriented Programming - OOP).
Database: MySQL.
Database Interaction: PHP Data Objects (PDO) for secure database interactions.
API Type: RESTful API endpoints for all data operations (CRUD for customers, equipment, parts, work orders, etc.). Responses should be JSON.
Security: Implement prepared statements, input validation, proper error handling, and a robust multi-tenant authorization system.
Core Features (Detailed Breakdown)
0. Shop Management (Platform Super Admin Only)
Create/Manage Shop:
Fields: shop_id (auto-generated UUID), shop_name (required), subscription_status (e.g., 'active', 'inactive', 'trial'), billing_email.
Functionality: Create new shop accounts, manage their subscription status.
View/Search Shops:
Display: List all registered shops.
Search: By shop_name, shop_id, subscription_status.
Access Shop Data: Super Admins and their employees can access and manage all data for any shop.
1. Customer Management (Shop-Specific)
Data Scope: All customer data must be associated with a shop_id.
Create Customer:
Fields: customer_id (auto-generated UUID), shop_id (FK, auto-assigned from logged-in shop), first_name (required), last_name (required), phone_number (required), email (optional, validated format), address (multi-line text, optional).
Functionality: Store new customer profiles for the active shop.
View/Search Customers:
Display: List all customers belonging to the current shop.
Search: By first_name, last_name, phone_number, email within the current shop's data.
Details: View full customer profile.
Edit Customer:
Functionality: Update any customer field for customers within the current shop.
Delete Customer:
Functionality: Remove customer profile (consider soft delete or restrict if linked to active work orders/equipment).
2. Equipment Management (Shop-Specific)
Data Scope: All equipment data must be associated with a shop_id.
Create Equipment:
Fields: equipment_id (auto-generated UUID), shop_id (FK, auto-assigned from logged-in shop), customer_id (FK, required to link to customer within the same shop), unit_type (e.g., 'Snowblower', 'Lawnmower', 'Chainsaw', 'ATV' - selectable list/dropdown), make (text input, required), model_number (text input, required), serial_number (text input, required, unique per shop), purchase_date (date picker, optional), notes (multi-line text, optional).
Functionality: Add new equipment and associate it with an existing customer within the same shop.
View/Search Equipment:
Display: List all equipment belonging to the current shop, showing linked customer name.
Search: By unit_type, make, model_number, serial_number, or by customer_name within the current shop's data.
Details: View full equipment details.
Edit Equipment:
Functionality: Update any equipment field, including re-linking to a different customer within the same shop if needed. serial_number can be updated, but uniqueness must be maintained.
Delete Equipment:
Functionality: Remove equipment (consider soft delete).
3. Parts Inventory Management (Shop-Specific)
Data Scope: All parts inventory data must be associated with a shop_id.
Create Part (Discrete):
Fields: part_id (auto-generated UUID), shop_id (FK, auto-assigned from logged-in shop), part_name (required), part_number (required, unique per shop), description (optional), cost_price (numeric, required), sale_price (numeric, required), quantity_on_hand (integer, required), minimum_stock_level (integer, optional), bin_location (text, optional - e.g., "A12", "Shelf 3, Bin 5").
Functionality: Add new discrete parts to inventory.
Create Part (Bulk Fluids/Oils):
Fields: part_id (auto-generated UUID), shop_id (FK, auto-assigned from logged-in shop), part_name (e.g., "Engine Oil 10W-30", "Hydraulic Fluid" - required), is_bulk (boolean, set to true), bulk_unit_measure (e.g., 'Litre', 'ml', 'Gallon', 'Quart' - selectable dropdown), bulk_total_cost_delivery (numeric, cost of the entire delivered bulk quantity), bulk_total_volume_delivered (numeric, total volume in bulk_unit_measure), bulk_markup_percentage (numeric, % to apply to cost to determine sale price per unit).
quantity_on_hand for bulk items will represent the current remaining volume.
Functionality: Add new bulk fluids/oils to inventory. Calculate sale_price_per_unit for bulk items based on bulk_total_cost_delivery, bulk_total_volume_delivered, and bulk_markup_percentage.
Associate Part with Vendor:
Functionality: Link an existing part (part_id) to one or more vendor_ids. This will allow filtering parts by vendor during order creation. A part can be supplied by multiple vendors.
View/Search Parts:
Display: List all parts, show quantity_on_hand (or remaining bulk_total_volume_delivered for bulk items). Highlight parts below minimum_stock_level.
Search: By part_name, part_number, bin_location, is_bulk status, or associated vendor_name within the current shop's data.
Edit Part:
Functionality: Update any part field, including quantity_on_hand and bin_location. For bulk items, allow updating of bulk-specific fields and recalculation of sale_price_per_unit. Also allow modifying vendor associations.
Delete Part:
Functionality: Remove part from inventory (consider restricting if used in past work orders).
3.1. Vendor Management (Shop-Specific)
Data Scope: All vendor data must be associated with a shop_id.
Create Vendor:
Fields: vendor_id (auto-generated UUID), shop_id (FK, auto-assigned), vendor_name (required, unique per shop), contact_person (optional), phone_number (optional), email (optional), address (multi-line text, optional), notes (multi-line text, optional).
Functionality: Add new vendor profiles for the active shop.
View/Search Vendors:
Display: List all vendors belonging to the current shop.
Search: By vendor_name, contact_person, phone_number.
Details: View full vendor profile.
Edit Vendor:
Functionality: Update any vendor field for vendors within the current shop.
Delete Vendor:
Functionality: Remove vendor profile (consider soft delete or restrict if linked to active parts orders).
3.2. Parts Order Management (Shop-Specific)
Data Scope: All parts order data must be associated with a shop_id.
Create Parts Order:
Fields: order_id (auto-generated UUID), shop_id (FK, auto-assigned), order_date (auto-populated), expected_delivery_date (optional), vendor_id (FK to vendors table, required), order_status (e.g., 'Draft', 'Ordered', 'Partially Received', 'Received', 'Canceled').
Order Line Items: For each part in the order: part_id (FK to parts table or temporary identifier if new part), ordered_quantity (integer), unit_cost_at_order (numeric), is_new_part (boolean, if part doesn't exist in inventory yet).
Functionality: Create a new order for parts from a selected vendor. When adding parts to the order, provide a filtered list of parts already associated with the selected vendor_id. Allow manual input for part_number and details if it's a new part not yet in inventory, and automatically associate this new part with the vendor upon successful reception.
View Parts Orders:
Display: List all parts orders for the current shop, showing status and associated vendor.
Search/Filter: By vendor_name, order_status, order_date.
Details: View full order details, including line items.
Receive Parts (Partial or Full):
Functionality:
Select an existing order_id to receive against.
For each line item in the order, input:
received_quantity (integer): How many units were actually received.
vendor_invoice_number (text, required for reception).
actual_cost_per_unit (numeric): The actual cost paid per unit for this reception.
is_backordered (boolean): Mark remaining unreceived quantity as backordered.
Inventory Update/Creation Logic:
If part_id exists in parts inventory: Add received_quantity to quantity_on_hand (for discrete parts) or bulk_total_volume_delivered (for bulk fluids) and update cost_price (average cost or latest cost, specify preference).
If part_id does not exist (marked is_new_part in order): Create a new part record in the parts inventory using details from the order line item and received quantity/cost, and automatically associate this new part with the vendor of the current order.
Update order_status (e.g., to 'Partially Received' or 'Received') based on quantities.
Record details of the reception (date, quantities, costs) in a separate order_receipts table for audit.
Edit Parts Order:
Functionality: Modify order details, add/remove line items (if not yet received), update status manually.
Delete Parts Order:
Functionality: Remove parts order (consider restrictions if already received parts).
4. Work Order Management (Shop-Specific)
Data Scope: All work order data must be associated with a shop_id.
Create Work Order:
Fields: work_order_id (auto-generated UUID), shop_id (FK, auto-assigned from logged-in shop), equipment_id (FK, required to link to equipment within the same shop), customer_id (FK, auto-populated from equipment), date_created (auto-populated), status (e.g., 'Open', 'In Progress', 'Ready for Pickup', 'Completed', 'Canceled' - selectable dropdown), reported_problem (multi-line text, required), diagnosis (multi-line text, optional), repair_notes (multi-line text, optional), technician_id (FK, optional, link to employee within the same shop).
Functionality: Create a new work order for a specific piece of equipment within the active shop.
Add Parts to Work Order:
Functionality: Select parts from inventory (of the current shop).
For discrete parts: specify quantity_used. Update quantity_on_hand in inventory automatically. Display sale_price for each part.
For bulk fluids/oils: specify volume_used (e.g., '2.5 Litres', '500 ml'). Automatically calculate the cost for the used volume based on the marked-up sale_price_per_unit of the bulk fluid. Deduct the volume_used from quantity_on_hand for the bulk item.
Display total cost for parts added.
Add Services to Work Order:
Functionality: Add service items with service_description (text), hours_spent (numeric), labour_rate_at_time (auto-populated from settings, or overrideable). Calculate service cost.
Calculate Total:
Functionality: Automatically calculate total_parts_cost, total_service_cost, and grand_total.
View Work Orders:
Display: List all work orders, filter by status, technician, customer, equipment (all within the current shop's data).
Details: View full work order details, including linked parts and services.
Edit Work Order:
Functionality: Update status, diagnosis, repair notes, add/remove parts/services. Adjust quantity_used for parts (within the current shop), including volume_used for bulk fluids and updating quantity_on_hand accordingly.
Delete Work Order:
Functionality: Remove work order (consider soft delete).
5. Service Appointment Scheduling (Shop-Specific)
Data Scope: All appointment data must be associated with a shop_id.
Create Appointment (Shop/Customer):
Fields: appointment_id (auto-generated UUID), shop_id (FK, auto-assigned), customer_id (FK, required), equipment_id (FK, optional, link to customer's equipment), appointment_date (date picker, required), appointment_time (time picker, required), service_type (e.g., 'Diagnosis', 'Repair', 'Maintenance' - selectable dropdown), notes (multi-line text, optional), status (e.g., 'Scheduled', 'Confirmed', 'Completed', 'Canceled').
Functionality:
Customer-Facing Page: A publicly accessible page for each shop where their customers can view available slots and book appointments, linking to their existing customer profile (if recognized) or creating a new one.
Shop Management Interface: Shop managers/employees (with appropriate roles) can manually create appointments, select existing customers/equipment, and assign service types.
View Appointments (Shop):
Display: Calendar view and list view of appointments for the current shop. Filter by date, status, technician.
Details: Show appointment details, linked customer and equipment info.
Edit Appointment (Shop):
Functionality: Update date, time, status, notes, or re-assign equipment/customer for appointments within the current shop.
Delete Appointment (Shop):
Functionality: Remove an appointment for appointments within the current shop.
6. Service History Tracking (Shop-Specific)
Data Scope: All service history must be associated with a shop_id.
Per Equipment Service History:
Functionality: For each piece of equipment (within the current shop), display a chronological list of all associated completed work orders, showing date_completed, reported_problem, diagnosis, repair_notes, parts_used, services_performed, and total cost for each.
7. Settings Management (Shop-Specific)
Data Scope: All settings data must be associated with a shop_id.
Labour Rate:
Field: shop_labour_rate (numeric, e.g., 75.00).
Functionality: Set and update the default shop labour rate for the current shop.
Employee/Technician Management (Shop-Specific):
Data Scope: Shop employees/technicians must be associated with a shop_id.
Create Employee:
Fields: employee_id (auto-generated UUID), shop_id (FK, auto-assigned from logged-in shop), first_name (required), last_name (required), role (e.g., 'Technician', 'Manager', 'Parts Manager', 'Service Manager', 'Admin' - selectable dropdown, with specific permissions for sales reporting).
View/Edit Employees: List all employees belonging to the current shop, allow editing of their details, including their roles and permissions for sales reporting access.
Delete Employee: Remove employee (consider restricting if linked to active work orders).
8. Platform User Management (Platform-Level)
Data Scope: This refers to the web app admin (me) and my employees who manage the entire WrenchFlow platform.
Users Table: A separate table (platform_users) or a distinct flag within the main users table to identify these users.
Roles: Super Admin (full access to all shops' data, ability to manage shops), Platform Employee (full access to all shops' data, possibly restricted shop management).
Login: These users will log in to a central platform dashboard.
9. Sales Management (Shop-Specific)
Data Scope: All sales data must be associated with a shop_id.
9.1. Over-the-Counter Parts Sales:
Functionality:
Create a new direct sale transaction.
Select existing parts from inventory (both discrete and bulk fluids) and specify quantity_sold (or volume_sold for bulk).
Display current sale_price for parts/fluids.
Allow optional linking to an existing customer_id.
Automatically decrement quantity_on_hand for sold items from inventory.
Record the sale_date, total_sale_amount, and total_cost_of_goods_sold for profit calculation.
Generate a simple sales receipt (printable/viewable).
9.2. Parts Sales Reporting & Profitability:
Display: Reports showing total parts sales (from work orders + over-the-counter), total cost of goods sold, and gross profit for parts.
Filters: By date range, part_name, part_number, customer, technician (for work order parts).
Metrics: Total units sold, total revenue, total cost, gross profit, gross profit margin.
Access: Accessible by Shop Administrators and Parts Employees (who have been granted explicit permission by a Shop Administrator).
9.3. Service Sales Reporting & Profitability:
Display: Reports showing total service sales and profit.
Filters: By date range, service_type, technician, customer.
Metrics: Total service hours, total service revenue, total cost of service (based on labor rate and hours), gross profit, gross profit margin.
Access: Accessible by Shop Administrators and Service Employees (who have been granted explicit permission by a Shop Administrator).
9.4. Overall Sales Dashboard:
Display: A summary dashboard showing total revenue and profit across both parts and services for a selected period.
Visualizations (Optional): Simple charts for trends (e.g., monthly sales).
Access: Accessible by Shop Administrators.
10. Theme Management (Shop-Specific & Platform-Level)
Data Scope: User theme preference stored per shop_user_id. Theme definitions are platform-level.
10.1. Platform Admin Theme Creation/Management:
Functionality:
Platform Super Admins and Platform Employees (with appropriate permissions) can define and manage a set of predetermined themes.
Each theme should have a theme_id (UUID), theme_name, and configuration details (e.g., a JSON blob or CSS variable definitions for primary color, secondary color, font families, background colors, etc.).
Display: List of available themes.
10.2. Shop User Theme Selection:
Functionality:
Shop Administrators and individual Shop Employees can select a preferred theme from the list of available themes for their own user interface.
This preference should be stored in their shop_users profile.
Display: A settings option for users to select their theme.
10.3. Dynamic Theme Application (Frontend):
Functionality:
The frontend JavaScript (CSS/Bootstrap) should dynamically load and apply the selected theme upon user login and when a theme is changed. This can be achieved by:
Loading different CSS files/variables based on the selected theme.
Applying specific Bootstrap utility classes or custom CSS rules that are conditionally applied.
Ensure smooth transitions when themes are switched (using CSS Transitions).
UI/UX Considerations
Responsiveness: Fully responsive layout for desktop, tablet, and mobile devices, ensuring usability on various screen sizes.
Design Aesthetic: Clean, professional, and intuitive user interface. Use clear typography and a consistent color scheme, adaptable via user themes.
Navigation: Clear and easy-to-use navigation (sidebar or top bar) to switch between Customers, Equipment, Parts, Work Orders, Settings, Appointments, Parts Orders, Vendors, Sales, and Themes. For Super Admins, include a "Shop Management" or "All Shops" section.
Forms: User-friendly forms with clear labels, input validation, and helpful feedback.
Data Tables: Clear, sortable, and searchable data tables for listing items (customers, equipment, parts, work orders, employees, appointments, parts orders, vendors, sales transactions).
Action Icons: All edit, create, and delete actions throughout the application should be represented by clear, intuitive icons instead of text buttons, leveraging Bootstrap's icon libraries or suitable SVG/Font Awesome icons.
Modals/Dialogs: Use custom modal dialogs for confirmations (e.g., delete actions) instead of alert() or confirm().
Offline-First & Synchronization Requirements (CRITICAL)
This is the most crucial and complex part. The application MUST function entirely offline.
Offline Data Storage (Frontend):
All application data (customers, equipment, parts, work orders, settings, employees, appointments, parts orders, vendors, sales transactions, and user theme preferences) must be stored locally in IndexedDB on the client-side, segregated by shop_id. A user should only have their shop's data cached.
When the application loads, it should attempt to load data from IndexedDB first for a fast, offline-ready experience.
Operational Resilience:
All Create, Read, Update, Delete (CRUD) operations performed by the user should first write/update the data in IndexedDB.
If offline, the operation is completed locally and marked as "pending sync".
The UI should reflect the local state, possibly indicating pending changes.
Synchronization Logic (Client-Side - JavaScript):
Implement robust JavaScript logic to detect online/offline status changes (window.addEventListener('online'), window.addEventListener('offline')).
When the app goes online:
Identify all data entries in IndexedDB that are marked as "pending sync" for the current shop_id.
Send these pending changes to the PHP backend via AJAX API calls. Prioritize changes logically (e.g., create customer, then create equipment for that customer, then create appointments, then create parts orders, then receive parts, then create vendors, then record sales, then update user theme preference). Each sync request must include the shop_id.
Upon successful response from the backend for a specific change, update the corresponding IndexedDB entry to "synced" or remove it from the pending queue.
Implement basic conflict resolution (e.g., for updates, "last-write-wins" or a simple timestamp-based check). For initial implementation, a simple merge or overwrite for updates is acceptable if conflicts are rare.
After syncing pending changes, trigger a full data refresh from the server to ensure the client has the most up-to-date information, and update IndexedDB with this fresh data.
Synchronization API (Backend - PHP):
Create dedicated PHP API endpoints (e.g., /api/sync/data) that can receive batches of data from the client (e.g., an array of customer updates, new equipment, etc.).
These endpoints must rigorously validate the shop_id provided in the request against the authenticated user's shop_id to prevent cross-shop data access.
They should process the incoming data, apply it to the MySQL database, and return success/failure messages, including any server-generated IDs for new records.
Handle potential data inconsistencies or errors gracefully on the server.
Initial Data Load:
When the app is first opened online, it should fetch all necessary data from the PHP API for the logged-in shop_id and populate IndexedDB. Subsequent loads can use IndexedDB first.
Additional Requirements
Error Handling: Implement robust error handling on both frontend (user-friendly messages, console logging) and backend (PHP try/catch blocks, structured error responses).
Security:
Sanitize all user inputs on the backend to prevent SQL injection and XSS.
Implement proper session management for user authentication (e.g., using secure, http-only cookies for session IDs).
Implement CSRF (Cross-Site Request Forgery) protection for all forms and state-changing actions.
PHP API endpoints should require authentication for all data modification operations.
Crucial Authorization Layer: All backend API calls must implement authorization checks based on the authenticated user's role and shop_id. Shop users can only access their shop_id's data. Platform Super Admins and Platform Employees can access all shop_id's data. For shop-level roles (Shop Administrator, Parts Employee, Service Employee), specific permissions must be enforced for access to sales reports and the ability to manage or select themes.
Code Structure:
PHP OOP & Modularity: Clearly defined and highly modular classes for models (e.g., Shop, Customer, Equipment, Part, Vendor, PartsOrder, OrderLineItem, OrderReceipt, WorkOrder, WorkOrderPart, WorkOrderService, Employee, Appointment, Sale, SaleLineItem, Theme, PlatformUser), controllers (for API logic), and a robust database helper class. Employ smart use of object-oriented principles (inheritance, interfaces, traits) where appropriate to ensure a clean, maintainable, and extensible codebase.
JavaScript: Modular structure, separating concerns into different files (e.g., indexeddb-service.js, api-service.js, ui-components.js, sync-manager.js, auth-service.js, appointment-booking.js, parts-ordering.js, vendor-management.js, sales-management.js, theme-manager.js).
Loading Indicators: Provide visual feedback (spinners, messages) during data loading and synchronization processes.
Initial Steps for Copilot
Project Structure: Create the initial project directory structure for PHP backend and frontend (HTML, CSS, JS).
MySQL Database Schema: Provide the SQL CREATE TABLE statements for shops, platform_users, shop_users (or a combined users table with a type and shop_id column, including selected_theme_id for individual user preference), customers, equipment, parts, vendors, part_vendor_relations (junction table for many-to-many), parts_orders, parts_order_line_items, parts_order_receipts, work_orders, work_order_parts, work_order_services, employees, appointments, sales (for over-the-counter transactions), sale_line_items (for parts sold over-the-counter), themes (platform-level definitions), and shop_settings. Emphasize the shop_id foreign key relationships where applicable.
Basic PHP API Setup: Create a config.php for database connection, a base index.php for API routing, and classes for authentication and authorization (Auth.php, AccessControl.php) that handle both shop-level and platform-level users.
IndexedDB Setup (Frontend): Provide a basic JavaScript file (indexeddb-service.js) with functions to open the database, create object stores, and add/get/update/delete data in IndexedDB, with consideration for shop_id and user_id scoping for theme preferences.
Offline Detection (Frontend): Implement basic JavaScript to detect and log online/offline status changes.
Dummy Data Insertion: Provide SQL queries to insert some dummy data into the MySQL tables for initial testing, including at least two shops and users for each, and a few sample theme definitions.